# Лаба 1

## Bad practices в написании Dockerfile:
### Неоптимальный базовый образ
Использование в `Dockerfile-good` `slim` образа позволяет снизить размер уже собранного образа, в `Dockerfile-bad` это не используется, следовательно сам образ получается больше.

### Неоптимальные run 
Неоптимальное использование команды `RUN` приводит к увеличению количества слоев, расширению образа, поэтому  в `Dockerfile-good` `apt-get update && apt-get install -y postgresql-client` происходит в одном `RUN`.

### Нет разделения окружения и проекта
Так как проект часто обновляется (условно с каждым коммитом), то копирование всего проекта и последующая сборка окружения приводит к увеличению времени сборки образа. Поэтоу в `Dockerfile-good` окружение собиарется отдельно и ДО копирования файлов, что позволяет использовать закешированное окружение при пересборке образа.

### Неэффективная установка пакетов
Использование в `Dockerfile-good` опции `--no-cache-dir` позволяет указать `pip`, что не стоит сохранять пакеты в кеше, что позволяет увеличить время билда образа. В `Dockerfile-bad` это не используется, следовательно сам образ получается больше.

## Когда не стоит использовать контейнеры в целом:
* Приложения с высокой потребностью в производительности, где каждая неэффективность на счету. Например, не стоит использовать для hft или для нагруженных баз данных.
* Старые легаси системы, которые тяжело контейнеризовать, которая обладает нестабильным окружением и тесно интегрирована с железом.
* Отсутствие необходимой среды выполнения, когда, например, в комании в целом не используется докер, или же используются более сложные конетйнеризаторы

### Запуск
```bash
# плохой докерфайл
docker build -f Dockerfile-bad -t bad_spicy_rag . && docker run -p 8501:8501 bad_spicy_rag

# хороший докерфайл
docker build -f Dockerfile-good -t good_spicy_rag . && docker run -p 8501:8501 good_spicy_rag
```